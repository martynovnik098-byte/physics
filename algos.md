Отлично, теперь у нас есть конкретная база! Твои лекции достаточно подробны и содержат специфику C++, которую наверняка спросят на зачете (например, про итераторы, шаблоны или устройство `std::stack`).

Я переработал ответы на твои вопросы, опираясь **строго на предоставленные лекции**. Именно такие формулировки от тебя ждет преподаватель.

---

### Блок 1: Основы и анализ алгоритмов (Лекция 1)

**В: Что такое алгоритм и какими свойствами он обладает?**
*   **Определение:** Это формально описанная вычислительная процедура, получающая входные данные и выдающая результат.
*   **Два ключевых свойства:**
    1.  **Конечность:** Алгоритм должен заканчивать работу за конечное число шагов на любых входных данных.
    2.  **Корректность:** На любых допустимых данных алгоритм выдает правильный результат.

**В: Как оценить эффективность? Что такое асимптотическая сложность?**
*   Для оценки используют две метрики: **время работы** и **размер используемой памяти**.
*   Чтобы не зависеть от мощности компьютера, считают не секунды, а количество операций.
*   Время работы представляется как функция $T(n)$. Например, для линейного поиска в худшем случае это $T(n) = C_1 + C_2n$ (линейная зависимость).
*   **Асимптотическая сложность ($O$-большое):** Это оценка скорости роста функции при $n \to \infty$. Мы отбрасываем константы и младшие слагаемые.
    *   *Пример:* Если $f(n) = n^3 + n^2$, то $f(n) = O(n^3)$, так как $\lim \frac{n^3 + n^2}{n^3} = 1$.

---

### Блок 2: Массивы и `std::vector` (Лекция 2)

**В: Как работает доступ к элементу массива? Сложность `operator[]`?**
*   **Сложность:** $O(1)$.
*   **Почему:** Массив занимает непрерывную область памяти. Адрес вычисляется по формуле:
    `Адрес = &a[0] + i * sizeof(element)`
    Где `&a[0]` — адрес начала, `i` — индекс.

**В: В чем разница между статическим и динамическим массивом?**
*   **Статический (`std::array`, C-style массив):** Размер фиксирован при создании (на этапе компиляции или запуска), изменить нельзя.
*   **Динамический (`std::vector`):** Может изменять размер во время выполнения.
    *   *Механизм:* Имеет `capacity` (ёмкость) и `size` (текущий размер). Когда место кончается, происходит реаллокация (выделение новой памяти и копирование).

**В: Зачем нужен `reserve()`?**
*   Чтобы зарезервировать место (`capacity`) заранее. Это позволяет избежать лишних реаллокаций памяти при добавлении элементов (`push_back`), сохраняя фактический `size` прежним.

**В: Как реализован линейный поиск?**
*   Перебор элементов с 0 до конца.
*   **Худший случай:** Элемент в конце или отсутствует — $O(n)$.
*   **Лучший случай:** Элемент первый — $O(1)$.
*   *Особенность из лекций:* Функция поиска часто возвращает специальное значение (например, `SIZE_MAX` или `iterator == end()`), если элемент не найден.

**В: Специфика C++ (Iterators, Templates):**
*   **Шаблоны (Templates):** Позволяют писать одну функцию (`print_array`, `find`) для разных типов данных. Ключевое слово `template<class T>`.
*   **Итераторы:** Легковесные объекты для перемещения по контейнеру. Работают как "умные указатели".
    *   `++it` — шаг вперед.
    *   `*it` — получение значения (разыменование).

---

### Блок 3: Сортировки (Лекция 3)

**В: Какие алгоритмы сортировки вы знаете? Сравните их.**
*Преподаватель дал четкую таблицу, ее нужно знать наизусть:*

| Алгоритм | Худшее время | Лучшее время | Особенности |
| :--- | :--- | :--- | :--- |
| **Выбором (Selection)** | $\Theta(n^2)$ | $\Theta(n^2)$ | Делает мало обменов ($\Theta(n)$). |
| **Вставками (Insertion)** | $\Theta(n^2)$ | $\Theta(n)$ | Эффективен на почти отсортированных данных. Аналогия с картами в руке. |
| **Слиянием (Merge)** | $\Theta(n \lg n)$ | $\Theta(n \lg n)$ | **Не** сортирует на месте (нужна доп. память). Стабильная (обычно). |
| **Быстрая (Quick)** | $\Theta(n^2)$ | $\Theta(n \lg n)$ | Сортирует на месте. Основана на принципе "Разделяй и властвуй" (partition). |

**В: Что такое "Стабильная" (устойчивая) сортировка?**
*   Это сортировка, которая **не меняет** порядок элементов с одинаковыми значениями относительно друг друга.

**В: Как работает Быстрая сортировка (Quick Sort)?**
1.  **Разделение (Partition):** Выбираем опорный элемент ($x$). Перекидываем всё, что меньше $x$, влево, а что больше — вправо.
2.  **Властвование:** Рекурсивно запускаем сортировку для левой и правой частей.
3.  **Объединение:** Не требуется, массив собирается сам собой.

---

### Блок 4: Связные списки (Лекция 3)

**В: В чем отличие списка от массива?**
*   Элементы списка (узлы) могут располагаться в памяти хаотично (не последовательно).
*   В узле хранятся данные + ссылка на следующий (и предыдущий для двусвязного) элемент.

**В: Что быстрее: пройтись по вектору или списку?**
*   **Ответ из лекции:** Вектор быстрее.
*   **Обоснование:** У списка элементы разбросаны в памяти, что приводит к "большому количеству неупорядоченных чтений памяти" (промахи кэша), в отличие от последовательного вектора.

**В: Виды списков:**
1.  **Односвязный:** Ссылка только на следующий. Двигаемся только вперед.
2.  **Двусвязный:** Ссылки на следующий и предыдущий. Можно удалять элемент, зная только указатель на него (без поиска).
3.  **Кольцевой:** Последний элемент ссылается на первый. `NULL` не встречается.

---

### Блок 5: Стек и Очередь (Лекция 4)

**В: Принципы работы стека и очереди?**
*   **Стек (Stack):** LIFO (Last In — First Out). "Стопка тарелок".
    *   Операции: `push` (добавить), `pop` (удалить с вершины).
*   **Очередь (Queue):** FIFO (First In — First Out). "Очередь в магазине".
    *   Операции: `enqueue/push` (в хвост), `dequeue/pop` (с головы).

**В: Как они реализованы в C++?**
*   Это **адаптеры** (обертки) над другими контейнерами.
*   `std::stack` по умолчанию использует `std::deque`.
*   `std::queue` по умолчанию использует `std::deque`.
*   Они ограничивают интерфейс: нельзя обратиться к произвольному элементу середины, только к `top` (у стека) или `front/back` (у очереди).

---

### Практические задачи (из лекций)

На зачете могут дать задачу на написание кода. В лекциях есть два примера, разбери их логику:

1.  **Игра в пьяницу (на Очередях):**
    *   Две колоды — это две `std::queue<int>`.
    *   Берем карты с `front()`, удаляем `pop()`.
    *   Сравниваем. Победитель кладет обе карты себе в низ колоды (`push()`).
    *   Важно: защита от бесконечного цикла (счетчик `step >= 1E6`).

2.  **Сортировка вагонов (Тупик — это Стек):**
    *   Есть путь 1 (вход, можно представить как очередь или поток ввода).
    *   Есть тупик (Стек, `std::stack`).
    *   Есть путь 2 (выход, должен быть 1, 2, 3...).
    *   Логика: Если вагон нужен сейчас — отправляем на путь 2. Если нет — загоняем в тупик. Если из тупика можно достать нужный — достаем.

---

### Чего НЕТ в лекциях (внимание!)
В твоих файлах **нет** информации про:
*   Хеш-таблицы (Hash Maps).
*   Бинарные деревья поиска (BST).
*   Сложность поиска в `std::set` или `std::map`.

Если преподаватель будет спрашивать строго по курсу, то вопросы про хеш-таблицы и деревья задавать **не должны**. Если спросят, можешь честно сказать: *"В курсе лекций мы рассматривали массивы, списки, сортировки, стеки и очереди. Деревья и хеш-таблицы, вероятно, будут в следующем семестре"*.

Но если это "общие знания", используй ответы из моего самого первого сообщения, но делай оговорку, что в лекциях этого не было.
