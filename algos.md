Привет! Это отличный список вопросов, покрывающий базу курса по АиСД. Если ты уверенно ответишь на них, зачет у тебя в кармане.

Ниже я подготовил развернутые ответы и объяснения для каждого пункта.

---

### Основные вопросы

#### 1. Как оценить эффективность алгоритма? Что такое асимптотическая сложность?
*   **Эффективность** оценивается по двум параметрам:
    1.  **Временная сложность:** сколько элементарных операций выполнит процессор.
    2.  **Пространственная сложность:** сколько дополнительной памяти потребует алгоритм.
*   **Асимптотическая сложность:** это способ описать, как растет время выполнения (или память) алгоритма при стремлении размера входных данных ($n$) к бесконечности. Мы отбрасываем константы и младшие слагаемые, потому что при больших $n$ они перестают играть роль.
    *   *Пример:* Если время $T(n) = 3n^2 + 50n + 100$, то асимптотика — $O(n^2)$.

#### 2. Выразите функцию в тета-обозначениях (Упр. 2.2.1 из Кормена)
*Функция:* $f(n) = \frac{n^3}{1000} - 100n^2 - 100n + 3$.
*   **Правило:** В $\Theta$-обозначении мы ищем функцию, которая ограничивает $f(n)$ и сверху, и снизу (с точностью до констант). Проще говоря, мы оставляем только слагаемое с самой высокой степенью и убираем коэффициенты.
*   **Решение:**
    1.  Самая высокая степень: $n^3$.
    2.  Остальные члены ($-100n^2$, $-100n$, $3$) растут медленнее, чем $n^3$, при $n \to \infty$.
    3.  Коэффициент $1/1000$ отбрасываем.
*   **Ответ:** $\Theta(n^3)$.

#### 3. Поиск элемента в массиве (Неотсортированный vs Отсортированный)
*   **Неотсортированный массив:**
    *   *Алгоритм:* **Линейный поиск** (перебор всех элементов подряд).
    *   *Лучший случай:* $O(1)$ (элемент стоит первым).
    *   *Худший случай:* $O(n)$ (элемент последний или его нет).
    *   *Средний случай:* $O(n)$ (в среднем проходим половину массива).
*   **Отсортированный массив:**
    *   *Алгоритм:* **Бинарный (двоичный) поиск**. Делим массив пополам, смотрим, в какой половине искомое число, повторяем.
    *   *Лучший случай:* $O(1)$ (попали в середину сразу).
    *   *Худший случай:* $O(\log n)$ (делим, пока не останется 1 элемент).
    *   *Средний случай:* $O(\log n)$.
    *   *Обоснование:* С каждой итерацией область поиска уменьшается в 2 раза. $2^k = n \Rightarrow k = \log_2 n$.

#### 4. Расположите функции по скорости роста
От самого быстрого (самая низкая сложность) к самому медленному (высокая сложность):
1.  $O(1)$ — константное время (мгновенно).
2.  $O(\lg n)$ — логарифмическое (бинарный поиск).
3.  $O(n)$ — линейное (проход циклом).
4.  $O(n \lg n)$ — линейно-логарифмическое (хорошие сортировки: MergeSort, QuickSort).
5.  $O(n^2)$ — квадратичное (вложенные циклы, пузырьковая сортировка).

#### 5. Динамический массив (std::vector) vs Связный список (std::list)
*   **Vector (Динамический массив):** Элементы лежат в памяти подряд.
    *   *Плюсы:* Мгновенный доступ по индексу $O(1)$, быстро работает с кэшем процессора.
    *   *Минусы:* Вставка/удаление в середину — $O(n)$ (нужно сдвигать элементы).
    *   *Когда использовать:* Почти всегда, если нужен произвольный доступ и добавление идет в основном в конец.
*   **List (Связный список):** Каждый элемент хранит значение и указатель на следующий. Элементы разбросаны по памяти.
    *   *Плюсы:* Вставка/удаление в любое место за $O(1)$ (если есть итератор на это место), не требует сдвига данных.
    *   *Минусы:* Доступ по индексу — $O(n)$ (нужно "прошагать" от начала), много промахов кэша.
    *   *Когда использовать:* Если нужно часто удалять/вставлять элементы в *середину* и не нужен доступ по индексу (например, `a[5]`).

#### 6. Словарь на Хеш-таблице (std::unordered_map)
*   **Принцип:** Хеш-функция преобразует ключ в индекс массива (бакета). При коллизиях (когда хеши совпадают) используется метод цепочек (список в ячейке) или открытая адресация.
*   **Сложность (Вставка, Удаление, Поиск):**
    *   *Лучший/Средний:* $O(1)$ (константа).
    *   *Худший:* $O(n)$ (если плохая хеш-функция, и все ключи попали в одну ячейку — вырождается в список).

#### 7. Словарь на Бинарном дереве поиска (std::map)
*   **Принцип:** Дерево, где для любого узла X: все ключи слева < X, все ключи справа > X. Обычно используются самобалансирующиеся деревья (Красно-черные или АВЛ).
*   **Сложность (Вставка, Удаление, Поиск):**
    *   *Сбалансированное дерево:* $O(\log n)$ (во всех случаях).
    *   *Несбалансированное (обычное BST):* В худшем случае $O(n)$ (превращается в "палку"), но в `std::map` такое невозможно, там гарантия $O(\log n)$.

#### 8 & 9. Множество на Дереве (std::set) и на Хеш-таблице (std::unordered_set)
Это то же самое, что и словари (пункты 6 и 7), только хранятся **только ключи** (без значений).
*   **Множество на дереве:** Сортирует элементы. Сложность операций: $O(\log n)$.
*   **Множество на хеш-таблице:** Не гарантирует порядок. Сложность операций: в среднем $O(1)$, худшая $O(n)$.

#### 10. Стек и Очередь
*   **Стек (Stack):** Принцип **LIFO** (Last In, First Out — последним зашел, первым вышел). Как стопка тарелок.
    *   *Реализация:* На векторе или списке.
    *   *Операции:* `push` (добавить), `pop` (удалить верхушку), `top` (посмотреть верхушку).
    *   *Сложность:* Все операции $O(1)$.
*   **Очередь (Queue):** Принцип **FIFO** (First In, First Out — первым зашел, первым вышел). Как очередь в магазине.
    *   *Реализация:* На списке или деке (deque). На векторе плохо (удаление с начала дорогое).
    *   *Операции:* `enqueue`/`push` (в конец), `dequeue`/`pop` (с начала).
    *   *Сложность:* Все операции $O(1)$.

---

### Дополнительные вопросы (на понимание C++)

**1. Сложность `operator[]` у `std::vector`. Почему?**
*   **Ответ:** $O(1)$.
*   **Почему:** Вектор гарантирует непрерывное расположение в памяти. Адрес элемента вычисляется по формуле: `Адрес = Начало_массива + (Индекс * Размер_типа)`. Это простая арифметика.

**2. Что быстрее: пройтись по `std::vector` или по `std::list`? Почему?**
*   **Ответ:** `std::vector` значительно быстрее.
*   **Почему:** Из-за **локальности кэша** (Cache Locality). Данные вектора лежат рядом, процессор загружает их в кэш "пачками" (cache lines). У списка каждый узел в случайном месте памяти, процессору приходится постоянно ждать загрузки данных из RAM (Cache Misses).

**3. Что быстрее: вставить $10^7$ элементов в пустой вектор или в пустой список?**
*   **Ответ:** Вектор быстрее.
*   **Почему:**
    1.  Список требует выделения памяти (malloc/new) для **каждого** элемента отдельно. Это очень дорого.
    2.  Вектор выделяет память редко (только при расширении). Если заранее сделать `vector.reserve()`, будет всего 1 выделение памяти.

**4-8. Сложность вставок и удалений в векторе:**
*   Вставка в **конец**: $O(1)$ амортизированное (в среднем константа, иногда $O(n)$ при реаллокации).
*   Вставка в **начало**: $O(n)$ (нужно сдвинуть все $N$ элементов вправо).
*   Вставка в **середину**: $O(n)$ (нужно сдвинуть хвост массива).
*   Удаление с **конца**: $O(1)$.
*   Удаление из **середины**: $O(n)$ (нужно сдвинуть хвост влево, чтобы закрыть дырку).

**9. Можно ли удалить произвольный элемент из вектора за $O(1)$?**
*   **Ответ:** Да, если **порядок элементов не важен**.
*   **Как:** Берем удаляемый элемент, меняем его местами с **последним** элементом (`std::swap`), а затем делаем `pop_back()` (удаляем последний).

**10. Задача про последовательность N чисел (частотный анализ).**
*   *Условие:* $N$ огромное ($10^{10}$), но сами числа маленькие (от 1 до 1000). Памяти мало.
*   **Решение:** Нам не нужно хранить всю последовательность ($10^{10}$ чисел). Нам нужно хранить только счетчики для чисел от 1 до 1000.
*   Создаем массив `counts` размером 1001, инициализируем нулями. Читаем числа по одному из потока ввода и делаем `counts[x]++`.
*   **Память:** $O(K)$, где $K=1000$ (константа).
*   **Время:** $O(N)$.

**11. Для чего нужен `reserve()` у `std::vector`?**
*   Чтобы заранее выделить кусок "сырой" памяти под ожидаемое количество элементов.
*   Это предотвращает многократные реаллокации (выделение новой памяти + копирование старых элементов) при добавлении элементов через `push_back`. Увеличивает производительность.

**12. Что такое `std::unordered_map` и зачем ему `reserve()`?**
*   `std::unordered_map` — это реализация хеш-таблицы в C++.
*   `reserve(n)` здесь нужен, чтобы заранее подготовить достаточное количество "корзин" (buckets) для хранения $n$ элементов.
*   Это предотвращает **rehashing** (полную перестройку таблицы), который происходит, когда коэффициент загрузки (load factor) превышает норму.

Удачи на зачете! Эти вопросы покрывают 90% того, что обычно спрашивают.
